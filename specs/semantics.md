


# ContextQL Semantics Specification

This document defines the *meaning* and *execution behavior* of ContextQL queries. While `syntax.md` defines how queries are written, this file clarifies how queries are interpreted, resolved, and executed in the engine.

## üîç Query Resolution Process

A ContextQL query is executed through the following conceptual steps:

1. **Permission context applied** (see `permissions.md`)
2. **Target nodes located** via `find`
3. **Filters evaluated** via `where` (field-level, boolean, and logical)
4. **Fields and edges resolved** via `return` and `expand`
5. **Nested expansion evaluated** if explicitly requested

---

### üß¨ Type Chain Matching

When a query uses `"find": "BaseType"`, the engine resolves it by matching any node whose `typeChain` includes the specified type or version. This allows queries and subscriptions to match derived or versioned types without requiring explicit references to each variation.

This behavior supports:

- Broad live-query subscriptions (`"find": "Lead"` matches `FacebookLead`, `InstagramLead`, etc.)
- Temporal replay across forks of a type lineage
- Structural stability across version migrations

---

### ‚è≥ Temporal Index Behavior

The fields `createdAt` and `updatedAt` are treated as reserved fields and recommended for all node types. They are indexed to support efficient filtering and backfill in live queries.

Use cases include:

- `since`-based catch-up in live subscriptions
- Sorting and limiting queries by recent activity
- Querying for mutations over a time window

These fields are scalar values and must be explicitly included in mutation payloads or generated by the engine at write-time.

## üß† Node Semantics

- Nodes are typed (`NodeType`) entities with fields and edges.
- Fields are atomic and must be scalars, arrays, or temporal primitives.
- Edges are directional links to other nodes and always require a label.
- Nodes are immutable once fetched‚Äîno transformations are applied in-query.

## üîó Relationship Semantics

- `expand` is an explicit edge traversal directive.
- Expansion is non-recursive by default; nested `expand` keys are required to traverse deeper.
- Relationship visibility is subject to the active permission context.
- No automatic join, fanout, or inferred linkage behavior exists.

## ‚è≥ Temporal Semantics

- Nodes and edges may include temporal fields such as `createdAt`, `updatedAt`, or custom timestamps.
- These are plain scalar fields; the engine does not natively interpret "state over time."
- Temporal logic is expressed via standard comparison operators in filters.

## ‚öñÔ∏è Evaluation Semantics

- All filters are evaluated using flat, stateless logic:
  - Logical operators (`$and`, `$or`) combine filter sets
  - Comparison operators (`$eq`, `$gt`, `$lt`, etc.) match scalar values
  - Array operators (`$in`, `$contains`) apply membership logic
- Evaluation is depth-first, deterministic, and side-effect free.
- No runtime computation, transformation, or derived fields are supported.

## ‚úÇÔ∏è Excluded Behaviors (By Design)

ContextQL will not support:

- **Derived values or computed expressions** inside queries
- **Field aliasing, renaming, or restructuring** of return values
- **Variable binding or symbolic references**
- **Dynamic sort expressions or scoring functions**
- **Group-by, reduce, or aggregate logic**
- **Recursion beyond explicitly nested `expand` statements**

These behaviors belong in the agent or application layer‚Äînot the query substrate.

## üß≠ Design Intent

ContextQL is not a developer DSL. It is a low-level semantic substrate designed for agents, systems, and permissioned automation. Its behavior is intentionally transparent and tightly scoped to data retrieval.

Rather than anticipate high-level shaping needs, ContextQL offers raw access to permissioned graph structure. This ensures predictability, introspection, and long-term durability.

---
This document works in tandem with `syntax.md` and `permissions.md` to define a stable, minimal contract for graph-native querying.